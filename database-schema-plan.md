# Database Schema Plan for Line-by-Line

## Overview
This schema supports a daily journaling app where users answer structured questions each day, with streak tracking and weekly visualization. Questions are flexible and can be customized or generated by LLMs.

## Core Tables

### 1. `entries` - Main journal entries
```sql
CREATE TABLE entries (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  entry_date DATE NOT NULL,
  content TEXT NOT NULL, -- The full entry text with questions and answers
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
  
  -- Ensure one entry per user per day
  UNIQUE(user_id, entry_date)
);
```

### 2. `user_settings` - User preferences and configuration
```sql
CREATE TABLE user_settings (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE NOT NULL,
  streak_days INTEGER[] DEFAULT '{1,2,3,4,5}' NOT NULL, -- 1=Monday, 2=Tuesday, etc.
  default_questions JSONB DEFAULT '[
    "What did you learn today?",
    "What was most confusing or challenging today?", 
    "What did you learn about how you learn?"
  ]' NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL
);
```

### 3. `question_templates` - Reusable question templates (for future LLM integration)
```sql
CREATE TABLE question_templates (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL,
  questions JSONB NOT NULL, -- Array of question strings
  is_active BOOLEAN DEFAULT true NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
  
  -- Users can have multiple templates with different names
  UNIQUE(user_id, name)
);
```

### 4. `streak_analytics` - For performance optimization of streak calculations
```sql
CREATE TABLE streak_analytics (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  current_streak INTEGER DEFAULT 0 NOT NULL,
  longest_streak INTEGER DEFAULT 0 NOT NULL,
  total_entries INTEGER DEFAULT 0 NOT NULL,
  last_entry_date DATE,
  calculated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
  
  UNIQUE(user_id)
);
```

## Indexes for Performance

```sql
-- Fast entry lookups by user and date
CREATE INDEX idx_entries_user_date ON entries(user_id, entry_date DESC);

-- Fast streak calculations
CREATE INDEX idx_entries_user_date_asc ON entries(user_id, entry_date ASC);

-- Fast settings lookup
CREATE INDEX idx_user_settings_user_id ON user_settings(user_id);

-- Fast question templates lookup
CREATE INDEX idx_question_templates_user_id ON question_templates(user_id);
CREATE INDEX idx_question_templates_active ON question_templates(user_id, is_active);

-- Fast analytics lookup
CREATE INDEX idx_streak_analytics_user_id ON streak_analytics(user_id);
```

## Row Level Security (RLS) Policies

### Entries Table
```sql
-- Enable RLS
ALTER TABLE entries ENABLE ROW LEVEL SECURITY;

-- Users can only see their own entries
CREATE POLICY "Users can view own entries" ON entries
  FOR SELECT USING (auth.uid() = user_id);

-- Users can insert their own entries
CREATE POLICY "Users can insert own entries" ON entries
  FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Users can update their own entries
CREATE POLICY "Users can update own entries" ON entries
  FOR UPDATE USING (auth.uid() = user_id);

-- Users can delete their own entries
CREATE POLICY "Users can delete own entries" ON entries
  FOR DELETE USING (auth.uid() = user_id);
```

### User Settings Table
```sql
-- Enable RLS
ALTER TABLE user_settings ENABLE ROW LEVEL SECURITY;

-- Users can only see their own settings
CREATE POLICY "Users can view own settings" ON user_settings
  FOR SELECT USING (auth.uid() = user_id);

-- Users can insert their own settings
CREATE POLICY "Users can insert own settings" ON user_settings
  FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Users can update their own settings
CREATE POLICY "Users can update own settings" ON user_settings
  FOR UPDATE USING (auth.uid() = user_id);
```

### Question Templates Table
```sql
-- Enable RLS
ALTER TABLE question_templates ENABLE ROW LEVEL SECURITY;

-- Users can only see their own templates
CREATE POLICY "Users can view own templates" ON question_templates
  FOR SELECT USING (auth.uid() = user_id);

-- Users can insert their own templates
CREATE POLICY "Users can insert own templates" ON question_templates
  FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Users can update their own templates
CREATE POLICY "Users can update own templates" ON question_templates
  FOR UPDATE USING (auth.uid() = user_id);

-- Users can delete their own templates
CREATE POLICY "Users can delete own templates" ON question_templates
  FOR DELETE USING (auth.uid() = user_id);
```

### Streak Analytics Table
```sql
-- Enable RLS
ALTER TABLE streak_analytics ENABLE ROW LEVEL SECURITY;

-- Users can only see their own analytics
CREATE POLICY "Users can view own analytics" ON streak_analytics
  FOR SELECT USING (auth.uid() = user_id);

-- Users can insert their own analytics
CREATE POLICY "Users can insert own analytics" ON streak_analytics
  FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Users can update their own analytics
CREATE POLICY "Users can update own analytics" ON streak_analytics
  FOR UPDATE USING (auth.uid() = user_id);
```

## Database Functions

### 1. Calculate User Streak
```sql
CREATE OR REPLACE FUNCTION calculate_user_streak(user_uuid UUID)
RETURNS INTEGER AS $$
DECLARE
  current_streak INTEGER := 0;
  check_date DATE := CURRENT_DATE;
  user_streak_days INTEGER[];
BEGIN
  -- Get user's streak days preference
  SELECT streak_days INTO user_streak_days 
  FROM user_settings 
  WHERE user_id = user_uuid;
  
  -- Default to weekdays if no settings found
  IF user_streak_days IS NULL THEN
    user_streak_days := '{1,2,3,4,5}';
  END IF;
  
  -- Calculate current streak
  WHILE TRUE LOOP
    -- Check if this date should have an entry (is a streak day)
    IF EXTRACT(DOW FROM check_date) = ANY(user_streak_days) THEN
      -- Check if entry exists for this date
      IF EXISTS (
        SELECT 1 FROM entries 
        WHERE user_id = user_uuid 
        AND entry_date = check_date
      ) THEN
        current_streak := current_streak + 1;
        check_date := check_date - INTERVAL '1 day';
      ELSE
        EXIT;
      END IF;
    ELSE
      -- Not a streak day, move to previous day
      check_date := check_date - INTERVAL '1 day';
    END IF;
  END LOOP;
  
  RETURN current_streak;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### 2. Update Streak Analytics
```sql
CREATE OR REPLACE FUNCTION update_streak_analytics(user_uuid UUID)
RETURNS VOID AS $$
DECLARE
  current_streak INTEGER;
  longest_streak INTEGER;
  total_entries_count INTEGER;
  last_entry_date_val DATE;
BEGIN
  -- Calculate current streak
  current_streak := calculate_user_streak(user_uuid);
  
  -- Get total entries count
  SELECT COUNT(*), MAX(entry_date)
  INTO total_entries_count, last_entry_date_val
  FROM entries 
  WHERE user_id = user_uuid;
  
  -- Get longest streak (this would need a more complex calculation)
  -- For now, we'll use current streak as longest
  longest_streak := current_streak;
  
  -- Insert or update analytics
  INSERT INTO streak_analytics (user_id, current_streak, longest_streak, total_entries, last_entry_date, calculated_at)
  VALUES (user_uuid, current_streak, longest_streak, total_entries_count, last_entry_date_val, NOW())
  ON CONFLICT (user_id) 
  DO UPDATE SET
    current_streak = EXCLUDED.current_streak,
    longest_streak = GREATEST(streak_analytics.longest_streak, EXCLUDED.longest_streak),
    total_entries = EXCLUDED.total_entries,
    last_entry_date = EXCLUDED.last_entry_date,
    calculated_at = NOW();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### 3. Get Weekly Entries
```sql
CREATE OR REPLACE FUNCTION get_weekly_entries(user_uuid UUID, week_start DATE)
RETURNS TABLE (
  entry_date DATE,
  content TEXT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    e.entry_date,
    e.content
  FROM entries e
  WHERE e.user_id = user_uuid
    AND e.entry_date >= week_start
    AND e.entry_date < week_start + INTERVAL '7 days'
  ORDER BY e.entry_date DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### 4. Get User's Active Questions (for LLM integration)
```sql
CREATE OR REPLACE FUNCTION get_user_questions(user_uuid UUID)
RETURNS JSONB AS $$
DECLARE
  active_template_questions JSONB;
  default_questions JSONB;
BEGIN
  -- Try to get active template questions first
  SELECT questions INTO active_template_questions
  FROM question_templates
  WHERE user_id = user_uuid AND is_active = true
  LIMIT 1;
  
  -- If no active template, get default questions from settings
  IF active_template_questions IS NULL THEN
    SELECT default_questions INTO default_questions
    FROM user_settings
    WHERE user_id = user_uuid;
    
    RETURN COALESCE(default_questions, '[
      "What did you learn today?",
      "What was most confusing or challenging today?", 
      "What did you learn about how you learn?"
    ]'::jsonb);
  END IF;
  
  RETURN active_template_questions;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

## Triggers

### 1. Update streak analytics when entries change
```sql
CREATE OR REPLACE FUNCTION trigger_update_streak_analytics()
RETURNS TRIGGER AS $$
BEGIN
  -- Update analytics for the affected user
  PERFORM update_streak_analytics(COALESCE(NEW.user_id, OLD.user_id));
  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER entries_streak_analytics_trigger
  AFTER INSERT OR UPDATE OR DELETE ON entries
  FOR EACH ROW
  EXECUTE FUNCTION trigger_update_streak_analytics();
```

### 2. Update timestamp on entry updates
```sql
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_entries_updated_at
  BEFORE UPDATE ON entries
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_settings_updated_at
  BEFORE UPDATE ON user_settings
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_question_templates_updated_at
  BEFORE UPDATE ON question_templates
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
```

## Migration Strategy

### Phase 1: Core Tables
1. Create `entries` table (simplified with just content)
2. Create `user_settings` table  
3. Create `question_templates` table
4. Create `streak_analytics` table
5. Add indexes
6. Enable RLS and create policies

### Phase 2: Functions and Triggers
1. Create streak calculation functions
2. Create weekly entries function
3. Create question retrieval function for LLM integration
4. Add triggers for automatic updates

### Phase 3: Data Migration
1. Create migration script to move localStorage data to Supabase
2. Update frontend to use Supabase instead of localStorage

## Benefits of This Revised Schema

1. **Flexibility**: No hardcoded questions - content is stored as-is
2. **LLM Ready**: Question templates can be generated and managed by LLMs
3. **Customizable**: Users can create multiple question templates
4. **Backward Compatible**: Existing localStorage data can be migrated easily
5. **Performance**: Still maintains efficient queries and indexing
6. **Future-Proof**: Easy to extend with new question types or formats

## Frontend Integration

The frontend can now:
1. **Fetch questions dynamically** using `get_user_questions()`
2. **Store complete entries** as formatted text
3. **Support multiple templates** for different journaling styles
4. **Integrate with LLMs** to generate new question sets

## Example Content Format

The `content` field would store entries like:
```
What did you learn today?
I learned about React hooks and how they can simplify component logic.

What was most confusing or challenging today?
Understanding the difference between useEffect and useMemo was tricky.

What did you learn about how you learn?
I learn best by building small examples and then gradually increasing complexity.
```

This approach gives you maximum flexibility while keeping the database schema simple and performant. 